<html lang="en">
<head>
    <title>Standard Storage</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }



        a {
            color: #a06851;
        }

        .nopadding {
            padding: 0 !important;
            margin: 0 !important;
        }



        /*MODAL FORM */
        /* The Modal (background) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 30px;
            /*width: 100%; */ /* Full width */
            /*height: 100%; */ /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        /* Modal Content/Box */
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
        }

        /* The Close Button */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

            .close:hover,
            .close:focus {
                color: black;
                text-decoration: none;
                cursor: pointer;
            }
    </style>

    <script src="js/three.js"></script>
    <script src="js/Projector.js"></script>
    <script src="js/ammo.js"></script>
    <script src="js/OrbitControls.js"></script>
    <!--<script src="js/TrackballControls.js"></script>  -->
    <script src="js/DragControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/ConvexObjectBreaker.js"></script>
    <script src="js/QuickHull.js"></script>
    <script src="js/ConvexGeometry.js"></script>
    <script src="js/jquery-3.2.1.min.js"></script>
    <script src="js/hierarchy.js"></script>
    <script src="js/w3.js"></script>
    <!--
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    -->
</head>
<body>
    
    <!--
    <div id="editor">
        <script>
            include_html("editor");
            $("#editor").load("editor.html?x=" + 1 * new Date());  //ensure refresh
        </script>
    </div>
    -->

    <!--  <object type="text/html" data="editor.html"></object>  -->

    <div>
        <!-- Trigger/Open The Modal -->
        <button id="myBtn">MANUAL</button>

        <!--
        <input type="button" value="switch1" id="switch1">
        <input type="button" value="switch2" id="switch2">
            -->

        <input type="button" value="Pallete" id="buttonPallete">
        <input type="button" value="Pal_left" id="buttonPallete_left">
        <input type="button" value="Pal_right" id="buttonPallete_right">
        <input type="button" value="emptyAll" id="emptyAll">
        <input type="button" value="takeFromCage" id="takeFromCage">
        <input type="button" value="slowMotion" id="slowMotion">
        SPEED:<input type="text" id="SPEED" value="0.1" size="5">
        <input type="range" id="speedRange" value="0.1" min="0.1" max="5.0" step="0.1">
        </br>
        P0:<input type="text" id="P0" value="0" size="5">
        P1:<input type="text" id="P1" value="0" size="5">
        P2:<input type="text" id="P2" value="0" size="5">
        P3:<input type="text" id="P3" value="0" size="5">
        P4:<input type="text" id="P4" value="0" size="5">
        P5:<input type="text" id="P5" value="0" size="5">


        <!-- The Modal -->
        <div id="myModal" class="modal">

            <!-- Modal content -->
            <div class="modal-content">

                <input type="button" value="L" id="buttonL">
                <input type="button" value="R" id="buttonR">
                <input type="button" value="U" id="buttonU">
                <input type="button" value="D" id="buttonD">
                <input type="button" value="I" id="buttonI">
                <input type="button" value="O" id="buttonO">
                <input type="button" value="slowM" id="slowMotionModal">
                <input type="button" value="LPin" id="buttonLPin">
                <input type="button" value="LPout" id="buttonLPout">
                <input type="button" value="RPin" id="buttonRPin">
                <input type="button" value="RPout" id="buttonRPout">
                <input type="button" value="STOP" id="buttonStop">

                <span class="close">&times;</span>
            </div>

        </div>




    </div>
    <div id="three_container"><br /><br /><br /><br /><br />Loading...</div>





    <script>

        //MODAL FORM
        // Get the modal
        var modal = document.getElementById('myModal');

        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");

        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];

        // When the user clicks on the button, open the modal
        btn.onclick = function () {
            modal.style.display = "block";
            is_on_manual = true;

            setTimeout(function () {
                save_port_4 = PORTS[4];
                save_port_5 = PORTS[5];
                PORTS[4] = 0;
                PORTS[5] = 0;
            }, 10);
        }

        // When the user clicks on <span> (x), close the modal
        span.onclick = function () {
            //console.log("span clicked");
            is_on_manual = false;
            smaphore_worker = 1;  // might become zero when c program is closed
            modal.style.display = "none";
            PORTS[4] = save_port_4;
            PORTS[5] = save_port_5;
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }




        // Detects webgl
        if (!Detector.webgl) {
            Detector.addGetWebGLMessage();
            document.getElementById('three_container').innerHTML = "";
        }

        // - Global variables -

        // Graphics variables
        var container, stats;
        var camera, controls, scene, renderer, projector;
        var textureLoader;
        var clock = new THREE.Clock();

        //raycaster
        var mouse = new THREE.Vector2(), INTERSECTED;
        var projector = new THREE.Projector();
        var raycaster = new THREE.Raycaster();
        var vector = new THREE.Vector3();

        var mouseVector = new THREE.Vector2();
        var containerWidth, containerHeight;



        var mouseCoords = new THREE.Vector2();
        var ballMaterial = new THREE.MeshPhongMaterial({ color: 0x202020 });



        var ballMaterial = new THREE.MeshPhongMaterial({ color: 0x202020 });

        // Physics variables
        var gravityConstant = 100;
        var collisionConfiguration;
        var dispatcher;
        var broadphase;
        var solver;
        var physicsWorld;
        var margin = 0.05;

        var convexBreaker = new THREE.ConvexObjectBreaker();

        // Rigid bodies include all movable objects
        var rigidBodies = [];
        var threeObjects = [];


        //drag ??
        var objects = [];


        var objectsToDrag = [];


        var pos = new THREE.Vector3();
        var quat = new THREE.Quaternion();
        var transformAux1 = new Ammo.btTransform();
        var tempBtVector = new Ammo.btVector3(0, 0, 0);

        var time = 0;




        var impactPoint = new THREE.Vector3();
        var impactNormal = new THREE.Vector3();


        //kit behaviour
        var delta_x = 0;
        var delta_y = 0;
        var delta_z = 0;
        var delta_left_station = 0;
        var delta_right_station = 0;
        var slowMotionConstant = 1.0;



        var previous_delta_z = 0;

        var SPEED = 0.1;

        var TOLERANCE = 0.0;

        var palleteCount = 0;
        var palletes = [];

        var PORTS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var save_port_4 = 0;
        var save_port_5 = 0;
        var the_worker;
        var smaphore_worker = 1;
        var is_on_manual = false;
        var sound1;
        var left_station;
        var left_station_sensor_x, left_station_sensor_y, left_station_sensor_z;


        var left_station_rolos=[];
        var right_station_rolos=[];


        // - Main code -
        $(window).on("load", function () {
            init();
            animate();
            ///AQUI  move_delta_linear(threeObjects["tower"], 100, 0, 0);
        });

        // - Functions -

        function init() {

            initGraphics();

            initPhysics();

            createObjects();


            //initRaycasterIdentification();
            initDrag();

            //initInput();

            initRaycasterIdentification();

            startWorker();

        }


        function initDrag() {
            //drag controlls
            var dragControls = new THREE.DragControls(objectsToDrag, camera, renderer.domElement);
            dragControls.addEventListener('dragstart', function (event) {
                controls.enabled = false;
            });
            dragControls.addEventListener('dragend', function (event) {
                controls.enabled = true;
            });
            /*var info = document.createElement( 'div' );
             info.style.position = 'absolute';
             info.style.top = '10px';
             info.style.width = '100%';
             info.style.textAlign = 'center';
             info.innerHTML = '<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - draggable cubes';
             container.appendChild( info );
             */
        }

        function initGraphics() {

            container = document.getElementById('three_container');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
            //camera = new THREE.PerspectiveCamera(60, $("#three_container").width() / $("#three_container").height(), 0.2, 2000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);

            camera.position.set(-10, 450, 450);

            // permitir que rato so funcione no div com o threejs

            controls = new THREE.OrbitControls(camera, container);
            controls.target.set(0, 2, 0);
            controls.update();
            /*
             controls = new THREE.TrackballControls( camera );
             controls.rotateSpeed = 1.0;
             controls.zoomSpeed = 1.2;
             controls.panSpeed = 0.8;
             controls.noZoom = false;
             controls.noPan = false;
             controls.staticMoving = true;
             controls.dynamicDampingFactor = 0.3;
             */



            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);


            /*
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize($("#three_container").width(), $("#three_container").height());
            */
            renderer.shadowMap.enabled = true;

            textureLoader = new THREE.TextureLoader();

            var ambientLight = new THREE.AmbientLight(0x707070);
            scene.add(ambientLight);

            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(-10, 18, 5);
            light.castShadow = true;
            var d = 14;
            light.shadow.camera.left = -d;
            light.shadow.camera.right = d;
            light.shadow.camera.top = d;
            light.shadow.camera.bottom = -d;

            light.shadow.camera.near = 2;
            light.shadow.camera.far = 50;

            light.shadow.mapSize.x = 1024;
            light.shadow.mapSize.y = 1024;

            scene.add(light);


            container.innerHTML = "";

            container.appendChild(renderer.domElement);

            //stats = new Stats();
            //stats.domElement.style.position = 'absolute';
            //stats.domElement.style.top = '0px';
            //container.appendChild(stats.domElement);


            //document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
            //renderer.domElement.addEventListener('mousedown', onCanvasMouseDown, false);
            var listener = new THREE.AudioListener();
            var audioLoader = new THREE.AudioLoader();
            sound1 = new THREE.PositionalAudio(listener);
            audioLoader.load('sounds/Crash.ogg', function (buffer) {
                sound1.setBuffer(buffer);
                sound1.setRefDistance(20);

            });

        }

        function initPhysics() {

            // Physics configuration
            collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            broadphase = new Ammo.btDbvtBroadphase();
            solver = new Ammo.btSequentialImpulseConstraintSolver();
            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

        }



        function createObjects() {

            // Ground
            pos.set(250, -0.5, 100);
            quat.set(0, 0, 0, 1);
            //    function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {
            var ground = createParalellepipedWithPhysics(1100, 30, 500, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xFFFFFF }));
            ground.receiveShadow = true;
            textureLoader.load("textures/grid.png", function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(40, 40);
                ground.material.map = texture;
                ground.material.needsUpdate = true;
            });
            var groundAxis = new THREE.AxisHelper(200);
            groundAxis.rotation.x = -Math.PI / 2;  //Rotation of axis
            groundAxis.position.x = -200;
            groundAxis.position.y = 30;
            groundAxis.position.z = 10;
            ground.add(groundAxis);
            scene.add(ground);


            //pilars
            for (i = 1; i <= 11; i++)
                for (j = 1; j <= 2; j++) {
                    obj = createBox("col" + i + j, -200 + (i - 1) * 75, 210, 0 - 90 * (j - 1), 0, 0, 0, 15, 390, 15, 0, "red", true);
                    scene.add(obj);
                }
            //low_base
            obj = createBox("low_base_1", 260, 17.5, 12.5, 0, 0, 0, 1000, 8, 10, 0, "blue", true);
            scene.add(obj);



            obj = createBox("carril_1", 260, 17.5, 30, 0, 0, 0, 1000, 8, 10, 0, 0x7D7373, true);
            scene.add(obj);


            obj = createBox("carril_2", 260, 17.5, 80, 0, 0, 0, 1000, 8, 10, 0, 0x7D7373, true);
            scene.add(obj);


            obj = createBox("roof_1", 227, 412.5, 0.2, 0, 0, 0, 955, 15, 15, 0, "silver", true);
            scene.add(obj);


            obj = createBox("roof_2", 175.5, 412.5, -90.2, 0, 0, 0, 765, 15, 15, 0, "silver", true);
            scene.add(obj);


            //cells
            for (i = 0; i < 10; i++) {
                for (j = 0; j < 5; j++) {
                    obj = createCylinder("cell_baseleft" + i + j, -183 + i * 75, 70 + 70 * j, -45, Math.PI / 2.0, 0, 0, 5, 105, 0, "yellow", true);
                    scene.add(obj);
                    obj = createCylinder("cell_baserigth" + i + j, -142 + i * 75, 70 + 70 * j, -45, Math.PI / 2.0, 0, 0, 5, 105, 0, "yellow", true);
                    scene.add(obj);
                }
            }

            for (i = 0; i < 10; i++) {
                for (j = 0; j < 5; j++) {
                    lat = createBox("lateral_left_" + i + j, -195.5 + i * 75, 80 + 70 * j, -45, 0, 0, 0, 5, 10, 75, 0, "silver", true);
                    scene.add(lat);
                    lat = createBox("lateral_right_" + i + j, -130.5 + i * 75, 80 + 70 * j, -45, 0, 0, 0, 5, 10, 75, 0, "silver", true);
                    scene.add(lat);

                }
            }


            //tower
            tower = createBox("tower", -140, 210, 80, 0, 0, 0, 15, 390, 15, 0, "silver", true);
            scene.add(tower);
            tower2 = createBox("tower2", -100, 210, 80, 0, 0, 0, 15, 390, 15, 0, "silver", true);
            scene.add(tower2);
            tower3 = createBox("tower3", -140, 210, 30, 0, 0, 0, 15, 390, 15, 0, "silver", true);
            scene.add(tower3);
            tower4 = createBox("tower4", -100, 210, 30, 0, 0, 0, 15, 390, 15, 0, "silver", true);
            scene.add(tower4);



            add_child(tower, tower2);
            add_child(tower, tower3);
            add_child(tower, tower4);

            tm1 = createBox("tower_motor1", -140, 407, 47.5, 0, 0, 0, 15, 5, 80, 0, "red", true);
            scene.add(tm1);

            tm2 = createBox("tower_motor2", -100, 407, 47.5, 0, 0, 0, 15, 5, 80, 0, "red", true);
            scene.add(tm2);

            tm3 = createBox("tower_motor3", -120, 412, 80, 0, 0, 0, 55, 5, 15, 0, "red", true);
            scene.add(tm3);

            tm4 = createBox("tower_motor4", -120, 412, 30, 0, 0, 0, 55, 5, 15, 0, "red", true);
            scene.add(tm4);

            tm5 = createBox("tower_motor5", -120, 420, 55, 0, 0, 0, 35, 20, 35, 0, "grey", true);
            scene.add(tm5);

            add_child(tower, tm1);
            add_child(tower, tm2);
            add_child(tower, tm3);
            add_child(tower, tm4);
            add_child(tower, tm5);


            /*
            //buttons and leds

            buttons_and_leds_base = createBox("buttons_and_leds_base", -227.13, 32.6, -45.62, 0, 0, 0, 40, 40, 90, 0, "silver", true);
            scene.add(buttons_and_leds_base);

            led1 = createCylinder("led1", -220, 55, -63, 0, 0, 0, 3, 5, 0, 0x006600, true);
            scene.add(led1);

            //buttons and leds
            led2 = createCylinder("led2", -220, 55, -20, 0, 0, 0, 3, 5, 0, 0x006600, true);
            scene.add(led2);


            switch1 = createBox("switch1", -235, 55, -63, 0, 0, 0, 3, 5, 5, 0, "red", true);
            scene.add(switch1);

            switch2 = createBox("switch2", -235, 55, -20, 0, 0, 0, 3, 5, 5, 0, "red", true);
            scene.add(switch2);
            */

            //cage
            cage = createBox("cage", -155, 127, 80, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(cage);
            cage2 = createBox("cage2", -155, 127, 30, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(cage2);
            cage3 = createBox("cage3", -230, 127, 80, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(cage3);
            cage4 = createBox("cage4", -230, 127, 30, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(cage4);

            cage5 = createBox("cage5", -230, 90, 55, 0, 0, 0, 15, 15, 65, 0, "red", true);
            scene.add(cage5);
            cage6 = createBox("cage6", -155, 90, 55, 0, 0, 0, 15, 15, 65, 0, "red", true);
            scene.add(cage6);

            cage7 = createBox("cage7", -230, 150, 55, 0, 0, 0, 15, 15, 65, 0, "red", true);
            scene.add(cage7);
            cage8 = createBox("cage8", -155, 150, 55, 0, 0, 0, 15, 15, 65, 0, "red", true);
            scene.add(cage8);


            cage9 = createBox("cage9", -195, 150, 80, 0, 0, 0, 65, 15, 15, 0, "red", true);
            scene.add(cage9);
            cage10 = createBox("cage10", -195, 150, 30, 0, 0, 0, 65, 15, 15, 0, "red", true);
            scene.add(cage10);


            cage11 = createBox("cage11", -195.5, 85.74, 84.81, 0, 0, 0, 65, 6, 6, 0, "red", true);
            scene.add(cage11);

            cage12 = createBox("cage12", -195.5, 85.74, 25.5, 0, 0, 0, 65, 6, 6, 0, "red", true);
            scene.add(cage12);


            //cage sensor
            cage_sensor = createCylinder("cage_sensor", -195, 150, 55, 0, 0, 0, 3, 45, 0, "black", true);
            cage_sensor.userData.type = "sensor";
            cage_sensor.userData.hint = "P0.0";

            scene.add(cage_sensor);
            objectsToDrag.push(cage_sensor);


            add_child(cage, cage2);
            add_child(cage, cage3);
            add_child(cage, cage4);
            add_child(cage, cage5);
            add_child(cage, cage6);
            add_child(cage, cage7);
            add_child(cage, cage8);
            add_child(cage, cage9);
            add_child(cage, cage10);
            add_child(cage, cage11);
            add_child(cage, cage12);
            add_child(cage, cage_sensor);
            add_child(tower, cage);







            conveyor = createBox("conveyor", -190, 93, 55, 0, 0, 0, 25, 6, 67, 0, "blue", true);
            scene.add(conveyor);
            add_child(cage, conveyor);


            conveyor_up = createBox("conveyor_up", -190, 98, 55, 0, 0, 0, 25, 4, 67, 0, "gray", true);
            conveyor_up.userData.attachedPallet = null;
            scene.add(conveyor_up);
            add_child(cage, conveyor_up);


            atcenter1 = createBox("atcenter1", -180, 88, 55, 0, 0, 0, 20, 5, 5, 0, "orange", true);
            scene.add(atcenter1);
            add_child(conveyor, atcenter1);
            objectsToDrag.push(atcenter1);

            atcenter2 = createBox("atcenter2", -160, 88, 55, 0, 0, 0, 20, 5, 5, 0, "green", true);
            scene.add(atcenter2);
            add_child(cage, atcenter2);
            objectsToDrag.push(atcenter2);


            atoutside1 = createBox("atoutside1", -180, 92.5, 25, 0, 0, 0, 20, 5, 5, 0, "orange", true);
            scene.add(atoutside1);
            add_child(conveyor, atoutside1);
            objectsToDrag.push(atoutside1);


            atoutside2 = createBox("atoutside2", -160, 92.5, 84.9, 0, 0, 0, 20, 5, 5, 0, "green", true);
            scene.add(atoutside2);
            add_child(cage, atoutside2);
            objectsToDrag.push(atoutside2);


            atinside1 = createBox("atinside1", -180, 97, 85.9, 0, 0, 0, 20, 5, 5, 0, "orange", true);
            scene.add(atinside1);
            add_child(conveyor, atinside1);
            objectsToDrag.push(atinside1);

            atinside2 = createBox("atinside2", -160, 97.5, 25.1, 0, 0, 0, 20, 5, 5, 0, "green", true);
            scene.add(atinside2);
            add_child(cage, atinside2);
            objectsToDrag.push(atinside2);


            cage_z = createBox("cage_z", -151, 104, 90, 0, 0, 0, 10, 5, 5, 0, "orange", true);
            scene.add(cage_z);
            add_child(cage, cage_z);
            objectsToDrag.push(cage_z);

            for (i = 1; i <= 5; i++) {
                at_z = createBox("at_z_" + i, -141, 60 + (i - 1) * 70, 90, 0, 0, 0, 10, 5, 5, 0, "green", true);
                scene.add(at_z);                
                add_child(tower, at_z);
                objectsToDrag.push(at_z);

                at_z_up = createBox("at_z_up_" + i, -141, 90 + (i - 1) * 70, 90, 0, 0, 0, 10, 5, 5, 0, "green", true);
                scene.add(at_z_up);
                add_child(tower, at_z_up);
                objectsToDrag.push(at_z_up);
            }

            at_x_0 = createBox("at_x_" + 0, -180, 18, 17, 0, 0, 0, 4, 4, 5, 0, "red", true);
            scene.add(at_x_0);
            at_x_11 = createBox("at_x_" + 11, 640, 18, 17, 0, 0, 0, 4, 4, 5, 0, "red", true);
            scene.add(at_x_11);


            for (i = 1; i <= 10; i++) {
                at_x = createBox("at_x_" + i, -109 + (i - 1) * 75, 18, 17, 0, 0, 0, 4, 4, 5, 0, "green", true);
                scene.add(at_x);
                objectsToDrag.push(at_x);
            }

            tower_at_x = createBox("tower_at_x", -140, 18, 21, 0, 0, 0, 4, 4, 4, 0, "orange", true);
            scene.add(tower_at_x);
            add_child(tower, tower_at_x);
            objectsToDrag.push(tower_at_x);

            //left station
            left_station = createBox("left_station",  -183,   45  , 160, 0, 0, 0, 15, 60, 105, 0, "red", true);
            left_station.userData.attachedPallet = null;
            scene.add(left_station);

            left_station1 = createBox("left_station1", -135, 45, 160, 0, 0, 0, 15, 60, 105, 0, "red", true);
            scene.add(left_station1);

            left_station_put = createBox("left_station_put", -159, 70, 195, 0, 0, 0, 33, 1.5, 20, 0, "orange", true);
            scene.add(left_station_put);

            ls_sup_s1 = createBox("ls_sup_s1", -110, 45, 115, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(ls_sup_s1);

            ls_sup_s2 = createBox("ls_sup_s2", -210, 45, 115, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(ls_sup_s2);

            ls_s1 = createBox("ls_s1", -204, 82, 115, 0, 0, 0, 3, 15, 15, 0, "orange", true);
            scene.add(ls_s1);
            objectsToDrag.push(ls_s1);


            ls_s2 = createBox("ls_s2", -116, 82, 115, 0, 0, 0, 3, 15, 15, 0, "black", true);
            scene.add(ls_s2);
            objectsToDrag.push(ls_s2);


            var arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(ls_s2.position.x, ls_s2.position.y, ls_s2.position.z), ls_s2.position.x - ls_s1.position.x, 0x69C9A3);
            scene.add(arrowHelper);

            for (i = 0; i < 35; i++) {
                xx = createBox("ls_rolo1" + i, -180, 75.3, 109 + i * 3, 0, 0, 0, 12, 0.5, 2.25, 1, "green", true);
                xx.userData.physicsBody.setFriction(1);
                scene.add(xx);
                left_station_rolos.push(xx);

                xx = createBox("ls_rolo2" + i, -138, 75.3, 109 + i * 3, 0, 0, 0, 12, 0.5, 2.25, 10, "green", true);
                xx.userData.physicsBody.setFriction(1);
                scene.add(xx);
                left_station_rolos.push(xx);
            }




            left_station_sensor_x = (ls_s1.position.x + ls_s2.position.x) / 2;
            left_station_sensor_y = (ls_s1.position.y + ls_s2.position.y) / 2;
            left_station_sensor_z = (ls_s1.position.z + ls_s2.position.z) / 2;

            




            right_station = createBox("right_station", -183 + 665, 45, 160, 0, 0, 0, 15, 60, 105, 0, "red", true);
            right_station.userData.attachedPallet = null;
            scene.add(right_station);

            right_station1 = createBox("right_station1", -135 + 665, 45, 160, 0, 0, 0, 15, 60, 105, 0, "red", true);
            scene.add(right_station1);

            right_station_put = createBox("right_station_put", -159 + 665, 70, 195, 0, 0, 0, 33, 1.5, 20, 0, "orange", true);
            scene.add(right_station_put);

            rs_sup_s1 = createBox("rs_sup_s1", -110 + 665, 45, 115, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(rs_sup_s1);

            rs_sup_s2 = createBox("rs_sup_s2", -210 + 665, 45, 115, 0, 0, 0, 15, 60, 15, 0, "red", true);
            scene.add(rs_sup_s2);

            rs_s1 = createBox("rs_s1", -204 + 665, 82, 115, 0, 0, 0, 3, 15, 15, 0, "orange", true);
            scene.add(rs_s1);
            objectsToDrag.push(rs_s1);

            rs_s2 = createBox("rs_s2", -116 + 665, 82, 115, 0, 0, 0, 3, 15, 15, 0, "black", true);
            scene.add(rs_s2);
            objectsToDrag.push(rs_s2);


            var arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(rs_s2.position.x, rs_s2.position.y, rs_s2.position.z), rs_s2.position.x - rs_s1.position.x, 0x69C9A3);
            scene.add(arrowHelper);
            


            for (i = 0; i < 35; i++) {
                xx = createBox("rs_rolo1" + i, -180 + 665, 75.3, 109 + i * 3, 0, 0, 0, 12, 0.5, 2.25, 1, "green", true);
                xx.userData.physicsBody.setFriction(1);
                scene.add(xx);
                right_station_rolos.push(xx);

                xx = createBox("rs_rolo2" + i, -138 + 665, 75.3, 109 + i * 3, 0, 0, 0, 12, 0.5, 2.25, 10, "green", true);
                xx.userData.physicsBody.setFriction(1);
                scene.add(xx);
                right_station_rolos.push(xx);
            }






            right_station_sensor_x = (rs_s1.position.x + rs_s2.position.x) / 2;
            right_station_sensor_y = (rs_s1.position.y + rs_s2.position.y) / 2;
            right_station_sensor_z = (rs_s1.position.z + rs_s2.position.z) / 2;

        }


        function createBox(name, px, py, pz, rx, ry, rz, sx, sy, sz, mass, _colour, isKeen) {
            threeObject = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), new THREE.MeshPhongMaterial({ color: _colour }));
            shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
            shape.setMargin(margin);
            threeObject.position.set(px, py, pz);

            threeObject.rotateX(rx);
            threeObject.rotateY(ry);
            threeObject.rotateZ(rz);



            threeObjects[name] = threeObject;
            threeObject.userData.name = name;

            createRigidSolid(threeObject, shape, mass, isKeen);
            return threeObject;

        }



        function createCylinder(name, px, py, pz, rx, ry, rz, radius, height, mass, _colour, isKeen) {



            threeObject = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, 20, 1), new THREE.MeshPhongMaterial({ color: _colour }));
            shape = new Ammo.btCylinderShape(new Ammo.btVector3(radius, height * 0.5, radius));
            shape.setMargin(margin);
            threeObject.position.set(px, py, pz);

            threeObject.rotateX(rx);
            threeObject.rotateY(ry);
            threeObject.rotateZ(rz);

            //cylAxis = new THREE.AxisHelper(100);
            //threeObject.add(cylAxis);


            threeObjects[name] = threeObject;
            threeObject.userData.name = name;

            createRigidSolid(threeObject, shape, mass, isKeen);

            threeObject.userData.physicsBody.setLinearVelocity(new Ammo.btVector3(0, 1, 0));

            return threeObject;

        }


        function createRigidSolid(threeObject, shape, mass, isKeen) {

            objects.push(threeObject);


            localInertia = new Ammo.btVector3(0, 0, 0);
            shape.calculateLocalInertia(mass, localInertia);
            transform = new Ammo.btTransform();
            transform.setIdentity();
            pos = threeObject.position;
            //rot = threeObject.rotation;
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));


            // worldQuaternion = new THREE.Quaternion();
            // worldQuaternion threeObject.getWorldQuaternion(  );
            q = threeObject.quaternion;


            transform.setRotation(new Ammo.btQuaternion(q.x, q.y, q.z, q.w));


            motionState = new Ammo.btDefaultMotionState(transform);
            rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            body = new Ammo.btRigidBody(rbInfo);

            body.setFriction(1);
             //body.setDamping(1);
            body.setRestitution(0);

            body.setActivationState(4);

            threeObject.userData.physicsBody = body;
            threeObject.receiveShadow = true;
            threeObject.castShadow = true;




            //threeObjects.push(threeObject);
            if (isKeen === false) {
                rigidBodies.push(threeObject);
            }
            physicsWorld.addRigidBody(body);
        }


        function initInput() {
            window.addEventListener('mousedown', function (event) {
                mouseCoords.set(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                raycaster.setFromCamera(mouseCoords, camera);
                // Creates a ball and throws it
                var ballMass = 35;
                var ballRadius = 2;
                var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
                ball.castShadow = true;
                ball.receiveShadow = true;
                var ballShape = new Ammo.btSphereShape(ballRadius);
                ballShape.setMargin(margin);
                pos.copy(raycaster.ray.direction);
                pos.add(raycaster.ray.origin);
                quat.set(0, 0, 0, 1);
                var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
                pos.copy(raycaster.ray.direction);
                pos.multiplyScalar(200);
                ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
            }, false);
        }

        

        function initRaycasterIdentification() {
            window.addEventListener('mousedown', function (event) {
                // find intersections
                mouseVector.x = 2 * (event.clientX / container.clientWidth) - 1;
                mouseVector.y = 1 - 2 * (event.clientY / container.clientHeight);

                //projector.unprojectVector(mouseVector, camera);


                raycaster.setFromCamera(mouseVector, camera);
                
                

                intersects = raycaster.intersectObjects(scene.children);


                for(var i = 0; i < intersects.length; i++ ) {
                    var intersection = intersects[ i ];
                    var obj = intersection.object;

                    if (typeof (obj.userData )!= 'undefined')
                        if (typeof (obj.userData.name )!= 'undefined')
                            console.log(obj.userData.name);

                    //obj.material.color.setRGB( 1.0 - i / intersects.length, 0, 0 );
                }



                /*
                camera.lookAt(scene.position);
                camera.updateMatrixWorld();
                raycaster.setFromCamera(mouse, camera);
                var intersects = raycaster.intersectObjects(scene.children);

                INTERSECTED = null;
                console.log(intersects.length);
                for (i = 0; i < intersects.length; i++) {

                    obj = intersects[i].object;
                    console.log(obj.userData.hint);
                    if (typeof(obj.userData) != 'undefined' && typeof(obj.userData.type) != 'undefined' && typeof(obj.userData.hint) != 'undefined'){
                        INTERSECTED = obj;
                        console.log(INTERSECTED.userData.hint);
                    }
                }
                if (INTERSECTED != null) {
                    //if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                    //INTERSECTED = intersects[0].object;
                    //INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    //INTERSECTED.material.emissive.setHex(0xff9999);
                    //console.log(obj.userData.hint);
                }
                */
            }, false);
        }



        function createObjectMaterial() {
            var c = Math.floor(Math.random() * (1 << 24));
            return new THREE.MeshPhongMaterial({ color: c });
        }


        function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

            if (pos) {
                object.position.copy(pos);
            } else {
                pos = object.position;
            }
            if (quat) {
                object.quaternion.copy(quat);
            } else {
                quat = object.quaternion;
            }

            var transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
            var motionState = new Ammo.btDefaultMotionState(transform);

            var localInertia = new Ammo.btVector3(0, 0, 0);
            physicsShape.calculateLocalInertia(mass, localInertia);

            var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
            var body = new Ammo.btRigidBody(rbInfo);

            body.setFriction(0.5);

            if (vel) {
                body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
            }
            if (angVel) {
                body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
            }

            object.userData.physicsBody = body;
            object.userData.collided = false;

            scene.add(object);

            if (mass > 0) {
                rigidBodies.push(object);

                // Disable deactivation
                body.setActivationState(4);
            }

            physicsWorld.addRigidBody(body);

            return body;
        }


        function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

            var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
            var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
            shape.setMargin(margin);

            createRigidBody(object, shape, mass, pos, quat);

            return object;

        }








        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            render();
            //stats.update();

        }




        function render() {

            var deltaTime = clock.getDelta();




            if ((PORTS[1] & 1 << 3) == 0)
            { //allow moving along xx only when yy is at center
                move_delta_linear(threeObjects["tower"], delta_x * slowMotionConstant, 0, 0);
            }
            move_delta_linear(threeObjects["cage"], 0, delta_y, 0);
            move_delta_linear(threeObjects["conveyor"], 0, 0, delta_z);
            move_delta_linear(threeObjects["conveyor_up"], 0, 0, delta_z * 1.5);


            if (left_station.userData.attachedPallet !== null)
                move_delta_linear(left_station.userData.attachedPallet, 0, 0, delta_left_station);
            if (right_station.userData.attachedPallet !== null)
                move_delta_linear(right_station.userData.attachedPallet, 0, 0, delta_right_station);

           
            if (delta_left_station !== 0) {
                for (var i = 0; i < left_station_rolos.length; i++) {
                    rolo = left_station_rolos[i];
                    move_delta_linear(rolo, 0, 0, delta_left_station);
                    if(rolo.position.z < 109 )
                        rolo.position.z = 211;
                    if (rolo.position.z > 211)
                        rolo.position.z = 109;
                    //Do something
                }
            }


            if (delta_right_station !== 0) {
                for (var i = 0; i < right_station_rolos.length; i++) {
                    rolo = right_station_rolos[i];
                    move_delta_linear(rolo, 0, 0, delta_right_station);
                    if (rolo.position.z < 109)
                        rolo.position.z = 211;
                    if (rolo.position.z > 211)
                        rolo.position.z = 109;
                    //Do something
                }
            }





            //updateSensorPorts();
            //establish_actuator_states();

            tryAttachment();
            tryDettachment();

            // seeClickedButtons();


            updatePhysics(deltaTime);
            controls.update();
            renderer.render(scene, camera);

            time += deltaTime;


        }

        /*
        function onDocumentMouseMove(event) {

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        }

        */
        /*
        //detect selected cube
        function onCanvasMouseDown(event) {
            if (INTERSECTED) {
                target = INTERSECTED;
                zoom = true;
            } else {
                zoom = false;
            }
        }
        */





        function updatePhysics(deltaTime) {

            // Step world
            physicsWorld.stepSimulation(deltaTime, 10);

            // Update rigid bodies

            for (var i = 0, il = rigidBodies.length; i < il; i++) {
                var objThree = rigidBodies[i];

                if (conveyor_up.userData.attachedPallet == objThree)    
                    //if (delta_x !== 0 || delta_z !== 0)   //TEMPORARY FIX avoid animation of pallets in cage  ++++++++
                    if (delta_y==0)   //TEMPORARY FIX avoid animation of pallets in cage  ++++++++
                        continue;

                var objPhys = objThree.userData.physicsBody;
                var ms = objPhys.getMotionState();
                if (ms) {
                    ms.getWorldTransform(transformAux1);

                    var p = transformAux1.getOrigin();
                    var q = transformAux1.getRotation();
                    objThree.position.set(p.x(), p.y(), p.z());
                    objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

                    objThree.userData.collided = false;


                }
                    
            }

        }




        $("#buttonL").click(function () {
            if (delta_x == 0 || delta_x == SPEED) {
                delta_x = -SPEED;
                PORTS[4] = setBitValue(PORTS[4], 1, true);
                PORTS[4] = setBitValue(PORTS[4], 0, false);
            }
            else {
                delta_x = 0;
                PORTS[4] = setBitValue(PORTS[4], 1, false);
                PORTS[4] = setBitValue(PORTS[4], 0, false);
            }


        });


        $("#buttonR").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 1, 0, 0);
            if (delta_x == 0 || delta_x == -SPEED) {
                delta_x = +SPEED;
                PORTS[4] = setBitValue(PORTS[4], 1, false);
                PORTS[4] = setBitValue(PORTS[4], 0, true);
            }
            else {
                delta_x = 0;
                PORTS[4] = setBitValue(PORTS[4], 1, false);
                PORTS[4] = setBitValue(PORTS[4], 0, false);
            }


        });
        $("#buttonU").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 1, 0);
            if (delta_y == 0 || delta_y == -SPEED) {
                delta_y = +SPEED;
                PORTS[4] = setBitValue(PORTS[4], 5, true);
                PORTS[4] = setBitValue(PORTS[4], 6, false);
            }
            else {
                delta_y = 0;
                PORTS[4] = setBitValue(PORTS[4], 5, false);
                PORTS[4] = setBitValue(PORTS[4], 6, false);
            }
            tryAttachment()
            tryDettachment();

        });
        $("#buttonD").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, -1, 0);
            if (delta_y == 0 || delta_y == SPEED) {
                delta_y = -SPEED;
                PORTS[4] = setBitValue(PORTS[4], 5, false);
                PORTS[4] = setBitValue(PORTS[4], 6, true);

            }
            else {
                delta_y = 0;
                PORTS[4] = setBitValue(PORTS[4], 5, false);
                PORTS[4] = setBitValue(PORTS[4], 6, false);

            }
            tryAttachment()
            tryDettachment();

        });

        $("#buttonI").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (delta_z == 0 || delta_z == SPEED) {
                delta_z = -SPEED;
                PORTS[4] = setBitValue(PORTS[4], 4, true);
                PORTS[4] = setBitValue(PORTS[4], 3, false);
            }
            else {
                delta_z = 0;
                PORTS[4] = setBitValue(PORTS[4], 4, false);
                PORTS[4] = setBitValue(PORTS[4], 3, false);
            }


        });
        $("#buttonO").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, 1);
            if (delta_z == 0 || delta_z == -SPEED) {
                delta_z = +SPEED;
                PORTS[4] = setBitValue(PORTS[4], 4, false);
                PORTS[4] = setBitValue(PORTS[4], 3, true);
            }
            else {
                delta_z = 0;
                PORTS[4] = setBitValue(PORTS[4], 4, false);
                PORTS[4] = setBitValue(PORTS[4], 3, false);
            }

        });


        $("#buttonLPin").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (delta_left_station == 0 || delta_left_station == SPEED) {
                delta_left_station = -SPEED;
                PORTS[4] = setBitValue(PORTS[4], 7, true);
                PORTS[5] = setBitValue(PORTS[5], 0, false);
            }
            else {
                delta_left_station = 0;
                PORTS[4] = setBitValue(PORTS[4], 7, false);
                PORTS[5] = setBitValue(PORTS[5], 0, false);
            }
        });

        $("#buttonLPout").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (delta_left_station == 0 || delta_left_station == -SPEED) {
                delta_left_station = SPEED;
                PORTS[4] = setBitValue(PORTS[4], 7, false);
                PORTS[5] = setBitValue(PORTS[5], 0, true);
            }
            else {
                delta_left_station = 0;
                PORTS[4] = setBitValue(PORTS[4], 7, false);
                PORTS[5] = setBitValue(PORTS[5], 0, false);
            }
        });


        $("#buttonRPin").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (delta_right_station == 0 || delta_right_station == SPEED) {
                delta_right_station = -SPEED;
                PORTS[5] = setBitValue(PORTS[5], 1, true);
                PORTS[5] = setBitValue(PORTS[5], 2, false);
            }
            else {
                delta_right_station = 0;
                PORTS[5] = setBitValue(PORTS[5], 1, false);
                PORTS[5] = setBitValue(PORTS[5], 2, false);
            }
        });

        $("#buttonRPout").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (delta_right_station == 0 || delta_right_station == -SPEED) {
                delta_right_station = SPEED;
                PORTS[5] = setBitValue(PORTS[5], 1, false);
                PORTS[5] = setBitValue(PORTS[5], 2, true);
            }
            else {
                delta_right_station = 0;
                PORTS[5] = setBitValue(PORTS[5], 1, false);
                PORTS[5] = setBitValue(PORTS[5], 2, false);
            }
        });

        //slowMotion
        $("#slowMotion,#slowMotionModal").click(function () {
            //move_delta_linear(threeObjects["conveyor"], 0, 0, -1);
            if (slowMotionConstant == 1.0) {
                slowMotionConstant = 0.1;
                PORTS[4] = setBitValue(PORTS[4], 2, true);
                console.log("slow Motion activated");
            }
            else {
                slowMotionConstant = 1.0;
                PORTS[4] = setBitValue(PORTS[4], 2, false);
                console.log("slow Motion DEACTIVATED");
            }
        });


        $("#buttonStop").click(function () {
            delta_x = 0;
            delta_y = 0;
            delta_z = 0;
            delta_left_station = 0;
            delta_right_station = 0;
            PORTS[4] = 0;
            PORTS[5] = 0;
        });



        /*

        var base_color1 = 0;
        $("#switch1").click(function () {
            if (base_color1 === 0)
                base_color1 = threeObjects["switch1"].material.color.getHex();
            if (threeObjects["switch1"].material.color.getHex() === base_color1) {
                threeObjects["switch1"].material.color.setHex(0xff9999)
                PORTS[1] = setBitValue(PORTS[1], 5, true);
            }
            else {
                threeObjects["switch1"].material.color.setHex(base_color1);
                PORTS[1] = setBitValue(PORTS[1], 5, false);
            }
        });
        */

        /*
        var base_color2 = 0;
        $("#switch2").click(function () {
            if (base_color2 === 0)
                base_color2 = threeObjects["switch2"].material.color.getHex();
            if (threeObjects["switch2"].material.color.getHex() === base_color2) {
                threeObjects["switch2"].material.color.setHex(0xff9999)
                PORTS[1] = setBitValue(PORTS[1], 6, true);
            }
            else {
                threeObjects["switch2"].material.color.setHex(base_color2);
                PORTS[1] = setBitValue(PORTS[1], 6, false);
            }

        });
        */

        function registerPallet(threePallete) {
            scene.add(pallete);
            palletes[palleteName] = pallete;
        }

        $("#buttonPallete").click(function () {
            palleteCount++;
            palleteName = "pallete" + palleteCount;
            conveyor_up = threeObjects["conveyor_up"];
            var x = conveyor_up.position.x;
            var y = conveyor_up.position.y;
            var z = conveyor_up.position.z;
            pallete = createBox(palleteName,
                    x, y + 20, z, 0, 0, 0, 50, 20, 50, 0.1, 0xff9900, false);
            add_child(conveyor_up, pallete);
            registerPallet(pallete);
        });


        $("#buttonPallete_left").click(function () {
            palleteCount++;
            palleteName = "pallete" + palleteCount;
            left_station_put = threeObjects["left_station_put"];
            var x = left_station_put.position.x;
            var y = left_station_put.position.y;
            var z = left_station_put.position.z;
            pallete = createBox(palleteName,
                    x, y + 40, z - 10, 0, 0, 0, 50, 20, 50, 10, 0xff9900, false);
            registerPallet(pallete);
        });


        $("#buttonPallete_right").click(function () {
            palleteCount++;
            palleteName = "pallete" + palleteCount;
            right_station_put = threeObjects["right_station_put"];
            var x = right_station_put.position.x;
            var y = right_station_put.position.y;
            var z = right_station_put.position.z;
            pallete = createBox(palleteName,
                    x, y + 40, z - 10, 0, 0, 0, 50, 20, 50, 0.1, 0xff9900, false);
            registerPallet(pallete);//+++++
        });


        //AQUI
        $("#emptyAll").click(function () {
            conveyor_up = threeObjects["conveyor_up"];
            if (conveyor_up.userData.attachedPallet !== null) {
                delete_child(conveyor_up, conveyor_up.userData.attachedPallet);
                conveyor_up.userData.attachedPallet = null;  
            }
            scene.remove(conveyor_up.userData.attachedPallet);
            conveyor_up.userData.attachedPallet = null;
            for (var key in palletes) {
                if (palletes.hasOwnProperty(key)) {
                    scene.remove(palletes[key]);
                    physicsWorld.removeRigidBody(palletes[key].userData.physicsBody);
                    delete threeObjects[key];
                    delete palletes[key];
                }
            }
            left_station.userData.attachedPallet = null;
            right_station.userData.attachedPallet = null;

        });

        $("#takeFromCage").click(function () {
            conveyor_up = threeObjects["conveyor_up"];
            if (conveyor_up.userData.attachedPallet !== null) {
                delete_child(conveyor_up, conveyor_up.userData.attachedPallet);
                scene.remove(conveyor_up.userData.attachedPallet);
                physicsWorld.removeRigidBody(conveyor_up.userData.attachedPallet.userData.physicsBody);
                delete threeObjects[conveyor_up.userData.attachedPallet.userData.name];
                delete palletes[conveyor_up.userData.attachedPallet.userData.name];
                conveyor_up.userData.attachedPallet != null;
            }

        });





        function tryAttachmentOfPallete_to_cage(pallete1) {
            conveyor_up = threeObjects["conveyor_up"];

            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;

            x1 = conveyor_up.position.x;
            y1 = conveyor_up.position.y;
            z1 = conveyor_up.position.z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
            //console.log("y2-y1=" + (y2 - y1));
            //console.log("dist=" + dist);


            if (dist <= 30 && (y2 - y1) > 0 && (y2 - y1) <= 16 ) { 
                add_child(conveyor_up, pallete1);
                conveyor_up.userData.attachedPallet = pallete1;

                //physicsWorld.removeRigidBody(conveyor_up.userData.attachedPallet.userData.physicsBody);
                //conveyor_up.userData.attachedPallet.userData.physicsBody.forceActivationState(2);
                //conveyor_up.userData.attachedPallet.userData.physicsBody.setTotalMass(0,false);

                console.log("pallete attached to cage.conveyor" + dist);
                return;
            }
        }


        function tryAttachmentOfPallete_to_left_station(pallete1) {

            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;
            /*


            x1 = left_station_sensor_x;//+++++
            y1 = left_station_sensor_y;
            z1 = left_station_sensor_z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
            z_dif = z2 - z1;
            //console.log("x2-x1="+(x2-x1)+"y2-y1="+(y2-y1)+"z2-z1="+(z2-z1));

            //console.log("z2-z1=" + (z2 - z1));
            if (dist <= 100 && ((x2 - x1) <= 5) && ((y2 - y1) <= 5) && ((z2 - z1) >= -5)) {
                //add_child(conveyor, pallete1);
                left_station.userData.attachedPallet = pallete1;
                console.log("pallete attached to left_station" + dist);
                return;
            }
            */

            left_station_1 = threeObjects["left_station"];
            left_station_2 = threeObjects["left_station1"];

            dist_y = pallete1.position.y - left_station_1.position.y;

            if(pallete1.position.x>left_station_1.position.x && pallete1.position.x<left_station_2.position.x)
                if(pallete1.position.z<(left_station_1.position.z+53) && pallete1.position.z>(left_station_1.position.z-53))
                    if (dist_y > 40 && dist_y < 42)
                    {
                        left_station.userData.attachedPallet = pallete1;
                        console.log("pallete attached to left_station dist_y=" + dist_y);
                    }


        }


        function tryAttachmentOfPallete_to_right_station(pallete1) {

            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;


            /*
            x1 = right_station_sensor_x;//+++++
            y1 = right_station_sensor_y;
            z1 = right_station_sensor_z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
            z_dif = z2 - z1;
            //console.log("x2-x1="+(x2-x1)+"y2-y1="+(y2-y1)+"z2-z1="+(z2-z1));

            //console.log("z2-z1=" + (z2 - z1));
            if (dist <= 100 && (Math.abs(x2 - x1) <= 5) && ((y2 - y1) <= 5) && ((z2 - z1) >= -5)) {
                //add_child(conveyor, pallete1);
                right_station.userData.attachedPallet = pallete1;
                console.log("pallete attached to right_station" + dist);
                return;
            }
            */

            right_station_1 = threeObjects["right_station"];
            right_station_2 = threeObjects["right_station1"];

            dist_y = pallete1.position.y - right_station_1.position.y;

            if (pallete1.position.x > right_station_1.position.x && pallete1.position.x < right_station_2.position.x)
                if (pallete1.position.z < (right_station_1.position.z + 53) && pallete1.position.z > (right_station_1.position.z - 53))
                    if (dist_y > 40 && dist_y < 42)
                {
                    right_station.userData.attachedPallet = pallete1;
                    console.log("pallete attached to right_station" + dist);
                }

        }



        function tryAttachment() {

            //if y axis is moving down or stopped then don't try attach
            //if( delta_y<=0)
            //    return;


            for (var key in palletes) {
                if (palletes.hasOwnProperty(key)) {
                    // if(conveyor.userData.children[key] === null)
                    if (conveyor_up.userData.attachedPallet == null || typeof conveyor_up.userData.attachedPallet == 'undefined')
                        tryAttachmentOfPallete_to_cage(palletes[key]);


                    if (left_station.userData.attachedPallet === null)
                        tryAttachmentOfPallete_to_left_station(palletes[key]);
                    if (right_station.userData.attachedPallet === null)
                        tryAttachmentOfPallete_to_right_station(palletes[key]);
                    //alert("Key is " + k + ", value is" + target[k]);
                }
            }

        }


        function tryDettachmentOfPallete_from_cage(pallete1) {
            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;

            conveyor_up = threeObjects["conveyor_up"];

            x1 = conveyor_up.position.x;
            y1 = conveyor_up.position.y;
            z1 = conveyor_up.position.z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));


            if (dist > 30 || (y2 - y1) < 0 || (y2 - y1) > 16 )
            {
                console.log("pallet detached from cage.conveyor" + dist);

                

               // physicsWorld.addRigidBody(conveyor_up.userData.attachedPallet.userData.physicsBody);
                //conveyor_up.userData.attachedPallet.userData.physicsBody.forceActivationState(4);
                //conveyor_up.userData.attachedPallet.userData.physicsBody.setTotalMass(100, false);

                delete_child(conveyor_up, conveyor_up.userData.attachedPallet);
                conveyor_up.userData.attachedPallet = null;
                //console.log(conveyor.userData.children);
            }

        }


        function tryDettachmentOfPallete_from_left_station(pallete1) {
            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;

            /*

            x1 = left_station_sensor_x;//+++++
            y1 = left_station_sensor_y;
            z1 = left_station_sensor_z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
            z_dif = z2 - z1;
            //console.log("x2-x1=" + (x2 - x1) + "y2-y1=" + (y2 - y1) + "z2-z1=" + (z2 - z1));


            if (((x2 - x1) > 5) || ((y2 - y1) > 5) || ((z2 - z1) < -12) || ((z2 - z1) > 100)) {
                //add_child(conveyor, pallete1);
                left_station.userData.attachedPallet = null;
                console.log("pallete detached from left_station" + dist);
                return;
            }

            */

            left_station_1 = threeObjects["left_station"];
            left_station_2 = threeObjects["left_station1"];

            dist_y = pallete1.position.y - left_station_1.position.y;

            if (pallete1.position.x < left_station_1.position.x || pallete1.position.x > left_station_2.position.x || pallete1.position.z > (left_station_1.position.z + 53) || pallete1.position.z < (left_station_1.position.z - 53)
                   || dist_y < 40)
                {
                    left_station.userData.attachedPallet = null;
                    console.log("pallete detached from left_station" + dist);                    
                }


        }


        function tryDettachmentOfPallete_from_right_station(pallete1) {
            if (pallete1 === null)
                return;
            if (typeof pallete1 === 'undefined')
                return;


            /*
            x1 = right_station_sensor_x;//+++++
            y1 = right_station_sensor_y;
            z1 = right_station_sensor_z;

            x2 = pallete1.position.x;
            y2 = pallete1.position.y;
            z2 = pallete1.position.z;

            dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
            z_dif = z2 - z1;
            //console.log("x2-x1=" + (x2 - x1) + "y2-y1=" + (y2 - y1) + "z2-z1=" + (z2 - z1));


            if (((x2 - x1) > 5) || ((y2 - y1) > 5) || ((z2 - z1) < -12) || ((z2 - z1) > 100)) {
                //add_child(conveyor, pallete1);
                right_station.userData.attachedPallet = null;
                console.log("pallete detached from right_station" + dist);
                return;
            }
            */


            right_station_1 = threeObjects["right_station"];
            right_station_2 = threeObjects["right_station1"];

            dist_y = pallete1.position.y - right_station_1.position.y;

            if (pallete1.position.x < right_station_1.position.x || pallete1.position.x > right_station_2.position.x
                || pallete1.position.z > (right_station_1.position.z + 53) || pallete1.position.z < (right_station_1.position.z - 53)
                    || dist_y < 40)
                {
                    right_station.userData.attachedPallet = null;
                    console.log("pallete detached from right_station" + dist);
                }


        }

        function tryDettachment() {

            //if(delta_y>=0 ) //don't try dettach if conveyor is falling or stopped
            //    return;
            //AQUI
            /*
            for (var key in palletes) {
                if (palletes.hasOwnProperty(key)) {
                    //if (conveyor.userData.children[key] !== null)
                        tryDettachmentOfPallete(palletes[key]);
                    //alert("Key is " + k + ", value is" + target[k]);
                }
            }
            */
            if (conveyor_up.userData.attachedPallet !== null && typeof conveyor_up.userData.attachedPallet !== 'undefined') {
                tryDettachmentOfPallete_from_cage(conveyor_up.userData.attachedPallet);
            }

            if (left_station.userData.attachedPallet !== null) {
                tryDettachmentOfPallete_from_left_station(left_station.userData.attachedPallet);


            }
            if (right_station.userData.attachedPallet !== null) {
                tryDettachmentOfPallete_from_right_station(right_station.userData.attachedPallet);
            }
        }

        $("#SPEED").focusout(function () {
            setSpeed();
        });

        $('#SPEED').on('keypress', function (e) {
            if (e.which === 13) {
                setSpeed();
            }
        });

        $(document).on('input', '#speedRange', function () {
            $('#SPEED').val($("#speedRange").val());
            setSpeed();
            // console.log($("#speedRange").val()  );
            // SPEED = $("#speedRange").val();
        });


        function setSpeed() {
            var aux = Number($("#SPEED").val());
            if (aux !== 'NaN') {
                SPEED = aux;
                $("#speedRange").val(SPEED);
            }
            //alert(SPEED);
        }


        function distance(obj1, obj2) {
            x = obj1.position.x - obj2.position.x;
            y = obj1.position.y - obj2.position.y;
            z = obj1.position.z - obj2.position.z;

            dist = Math.sqrt(x * x + y * y + z * z);
            return dist;
        }

        function setBitValue(byteValue, bit, logicalLevel) {

            if (logicalLevel === true) {
                mask = 1 << bit;
                result = byteValue | mask;
            } else {
                mask = ~(1 << bit);
                result = byteValue & mask;
            }
            return result;
        }



        function updateSensorPorts() {
            atcenter1 = threeObjects["atcenter1"];
            atcenter2 = threeObjects["atcenter2"];

            atoutside1 = threeObjects["atoutside1"];
            atoutside2 = threeObjects["atoutside2"];

            atinside1 = threeObjects["atinside1"];
            atinside2 = threeObjects["atinside2"];

            cage_z = threeObjects["cage_z"];

            tower_at_x = threeObjects["tower_at_x"];


            if (distance(atinside1, atinside2) < 21 + SPEED+TOLERANCE)
                PORTS[1] = setBitValue(PORTS[1], 4, false);
            else
                PORTS[1] = setBitValue(PORTS[1], 4, true);

            if (distance(atcenter1, atcenter2) < 21 + SPEED+TOLERANCE)
                PORTS[1] = setBitValue(PORTS[1], 3, false);
            else
                PORTS[1] = setBitValue(PORTS[1], 3, true);

            if (distance(atoutside1, atoutside2) < 21 + SPEED + TOLERANCE)
                PORTS[1] = setBitValue(PORTS[1], 2, false);
            else
                PORTS[1] = setBitValue(PORTS[1], 2, true);


            PORTS[2] = setBitValue(PORTS[2], 7, false);
            for (var key in palletes) {
                if (palletes.hasOwnProperty(key)) {
                    dist = distance(palletes[key], threeObjects["cage_sensor"]);
                    if (dist <= 42+SPEED+TOLERANCE)
                        PORTS[2] = setBitValue(PORTS[2], 7, true);
                    // console.log("pall_dist=" + dist);
                    //alert("Key is " + k + ", value is" + target[k]);
                }
            }


            ppp = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]; // -1 is useless value
            bbb = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1]; // -1 is useless value
            for (i = 1; i <= 10; i++) {
                at_x = threeObjects["at_x_" + i];

                if (distance(tower_at_x, at_x) <= 6 + SPEED + TOLERANCE)
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], false);
                else
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], true);
            }

            ppp = [-1, 2, 2, 2, 2, 1]; // -1 is useless value
            bbb = [-1, 6, 4, 2, 0, 6]; // -1 is useless value
            for (i = 1; i <= 5; i++) {
                at_z = threeObjects["at_z_" + i];

                if (distance(cage_z, at_z) <= 11.5 + SPEED + TOLERANCE)
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], false);
                else
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], true);
            }

            ppp = [-1, 2, 2, 2, 1, 1]; // -1 is useless value
            bbb = [-1, 5, 3, 1, 7, 5]; // -1 is useless value
            for (i = 1; i <= 5; i++) {
                at_z_up = threeObjects["at_z_up_" + i];

                if (distance(cage_z, at_z_up) <= 11.5 + SPEED + TOLERANCE)
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], false);
                else
                    PORTS[ppp[i]] = setBitValue(PORTS[ppp[i]], bbb[i], true);
            }


            PORTS[3] = setBitValue(PORTS[3], 0, false);
            if (left_station.userData.attachedPallet !== null) {
                pall = left_station.userData.attachedPallet
                

                dist_x = Math.abs(left_station_sensor_x - pall.position.x);
                dist_y = Math.abs(left_station_sensor_y - pall.position.y);
                dist_z = Math.abs(left_station_sensor_z - pall.position.z);

                if(dist_x<25 && dist_y<10 && dist_z<25)
                        PORTS[3] = setBitValue(PORTS[3], 0, true);

            }


            PORTS[3] = setBitValue(PORTS[3], 1, false);
            if (right_station.userData.attachedPallet !== null) {
                pall = right_station.userData.attachedPallet
                
                dist_x = Math.abs(right_station_sensor_x - pall.position.x);
                dist_y = Math.abs(right_station_sensor_y - pall.position.y);
                dist_z = Math.abs(right_station_sensor_z - pall.position.z);

                if (dist_x < 25 && dist_y < 10 && dist_z < 25)
                    PORTS[3] = setBitValue(PORTS[3], 1, true);

            }



            update_all_sensors_colors();


            $("#P0").val(toBinary(PORTS[0]));
            $("#P1").val(toBinary(PORTS[1]));
            $("#P2").val(toBinary(PORTS[2]));
            $("#P3").val(toBinary(PORTS[3]));
            $("#P4").val(toBinary(PORTS[4]));
            $("#P5").val(toBinary(PORTS[5]));


            //console.log(PORTS[0]);
            //console.log(distance(cage_z, threeObjects["at_z_up_1"] ));
        }


        function update_all_sensors_colors() {
            update_sensor_color(threeObjects["at_x_1"], PORTS[0] & 1 << 0, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_2"], PORTS[0] & 1 << 1, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_3"], PORTS[0] & 1 << 2, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_4"], PORTS[0] & 1 << 3, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_5"], PORTS[0] & 1 << 4, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_6"], PORTS[0] & 1 << 5, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_7"], PORTS[0] & 1 << 6, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_8"], PORTS[0] & 1 << 7, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_9"], PORTS[1] & (1 << 0), 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_x_10"], PORTS[1] & 1 << 1, 0, 0x99ff99, 0x006600);


            update_sensor_color(threeObjects["at_z_1"], PORTS[2] & 1 << 6, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_2"], PORTS[2] & 1 << 4, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_3"], PORTS[2] & 1 << 2, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_4"], PORTS[2] & 1 << 0, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_5"], PORTS[1] & 1 << 6, 0, 0x99ff99, 0x006600);


            update_sensor_color(threeObjects["at_z_up_1"], PORTS[2] & 1 << 5, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_up_2"], PORTS[2] & 1 << 3, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_up_3"], PORTS[2] & 1 << 1, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_up_4"], PORTS[1] & 1 << 7, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["at_z_up_5"], PORTS[1] & 1 << 5, 0, 0x99ff99, 0x006600);


            update_sensor_color(threeObjects["atinside2"], PORTS[1] & 1 << 4, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["atcenter2"], PORTS[1] & 1 << 3, 0, 0x99ff99, 0x006600);
            update_sensor_color(threeObjects["atoutside2"], PORTS[1] & 1 << 2, 0, 0x99ff99, 0x006600);

            update_sensor_color(threeObjects["cage_sensor"], PORTS[2] & 1 << 7, 1, 0x99ff99, 0x000000);

            update_sensor_color(threeObjects["cage_sensor"], PORTS[2] & 1 << 7, 1, 0x99ff99, 0x000000);

            update_sensor_color(threeObjects["ls_s2"], PORTS[3] & 1 << 0, 1, 0x99ff99, 0x000000);

            update_sensor_color(threeObjects["rs_s2"], PORTS[3] & 1 << 1, 1, 0x99ff99, 0x000000);

            if ((PORTS[4] & (1 << 2)) !== 0) {
                $("#slowMotion").css("background-color", "#ff9999");
                slowMotionConstant = 0.1;
            } else {
                $("#slowMotion").css("background-color", "");
                slowMotionConstant = 1.0;
            }


        }


        function update_sensor_color(threeObject, state_value, activation_level, active_color, inactive_color) {
            if (activation_level === 0) {
                if (state_value === 0)
                    threeObject.material.color.setHex(active_color);
                else
                    threeObject.material.color.setHex(inactive_color);
            }
            if (activation_level === 1) {
                if (state_value !== 0)
                    threeObject.material.color.setHex(active_color);
                else
                    threeObject.material.color.setHex(inactive_color);
            }


        }


        function startWorker() {
            if (typeof (Worker) !== "undefined") {
                if (typeof (the_worker) === "undefined") {
                    the_worker = new Worker("js/theworker.js");
                }
                the_worker.onmessage = worker_event;
                /*** fim post data *****/
            } else {
                //document.getElementById("result").innerHTML = "Sorry! No Web Worker support.";
                console.log("Sorry! No Web Worker support.");
            }
        }


        //http://localhost:8081/ajax_port_values?P0=0&P1=1&P2=2&P3=3&P4=4&P5=5
        function worker_event(event) {
            //console.log("manual=" + is_on_manual + "semaphore=" + smaphore_worker);
            if ( smaphore_worker == 1) {
                smaphore_worker = 0;

                updateSensorPorts();
                

                $.post("ajax_port_values", {
                    "P0": PORTS[0],
                    "P1": PORTS[1],
                    "P2": PORTS[2],
                    "P3": PORTS[3],
                    "P4": PORTS[4],
                    "P5": PORTS[5]
                }, function (data, status) {

                    smaphore_worker = 1;
                    //console.log(PORTS);
                    if (is_on_manual == false) {
                        registers = JSON.parse(data);
                        // console.log(registers['P2']);

                        //AQUI  IMPORTANTE <<<<------------------------------------------- IMPORTANTE
                        PORTS[4] = registers['P4'];
                        PORTS[5] = registers['P5'];
                        establish_actuator_states();
                    }


                }).fail(function (error) {
                    smaphore_worker = 1;
                    console.log("here is the error: " + error);
                });
            }

        }
        function establish_actuator_states() {
            //stop movement  on xx limits
            tower_at_x = threeObjects["tower_at_x"];
            at_x_0 = threeObjects["at_x_0"];
            distxx = distance(tower_at_x, at_x_0);

            if ((PORTS[4] & (1 << 1)) && distxx <= 6) {  //if moving  left and reaching limit, stop
                PORTS[4] = setBitValue(PORTS[4], 1, false);
                threeObjects["at_x_0"].material.color.setHex(0xff9999)
                sound1.play();
            } else if (distxx > 6)
                threeObjects["at_x_0"].material.color.setHex(0xff0000)

            at_x_11 = threeObjects["at_x_11"];
            distxx = distance(tower_at_x, at_x_11);
            if ((PORTS[4] & (1 << 0)) && distxx <= 6) {  //if moving  right and reaching limit, stop
                PORTS[4] = setBitValue(PORTS[4], 0, false);
                threeObjects["at_x_11"].material.color.setHex(0xff9999)
                sound1.play();
            } else if (distxx > 6)
                threeObjects["at_x_11"].material.color.setHex(0xff0000)



            P4 = PORTS[4];
            P5 = PORTS[5];

            delta_x = 0;
            if ((P4 & 1 << 1) !== 0)
                delta_x = -SPEED;   //move_left
            if ((P4 & 1 << 0) !== 0)
                delta_x = SPEED;    //move_right

            delta_y = 0;
            if ((P4 & 1 << 5) !== 0)
                delta_y = SPEED;    //move_up
            if ((P4 & 1 << 6) !== 0)
                delta_y = -SPEED;   //move_down

            delta_z = 0;
            if ((P4 & 1 << 4) !== 0)
                delta_z = -SPEED;   //move_inside
            if ((P4 & 1 << 3) !== 0)
                delta_z = SPEED;    //move_outside
            

            delta_left_station = 0;
            if ((P4 & (1 << 7)) !== 0)
                delta_left_station = -SPEED;  
            if ((P5 & (1 << 0)) !== 0)
                delta_left_station = SPEED;

            delta_right_station = 0;
            if ((P5 & (1 << 1)) !== 0)
                delta_right_station = -SPEED;
            if ((P5 & (1 << 2)) !== 0)
                delta_right_station = SPEED;

            
            /*
            if ((P2 & 1 << 0) !== 0)
                threeObjects["led1"].material.color.setHex(0x99ff99);
            else
                threeObjects["led1"].material.color.setHex(0x006600);

            if ((P2 & 1 << 1) !== 0)
                threeObjects["led2"].material.color.setHex(0x99ff99);
            else
                threeObjects["led2"].material.color.setHex(0x006600);
                */


        }



    </script>

</body>
</html>